# 任務清單：智慧選卡器

**輸入**: 設計文件來自 `/specs/001-smart-card-selector/`
**前置條件**: plan.md（必要）、spec.md（必要，用於使用者故事）、data-model.md、contracts/

**測試**: 本專案採用手動測試策略，不包含自動化測試任務。

**組織方式**: 任務按使用者故事分組，以實現獨立實作和測試。

## 格式：`[ID] [P?] [Story] 描述`

- **[P]**: 可並行執行（不同檔案，無依賴）
- **[Story]**: 此任務屬於哪個使用者故事（如 US1、US2、US3）
- 描述中包含確切的檔案路徑

## 路徑慣例

- **單一專案**: 根目錄的 `index.html`、`app.js`、`styles.css`
- 下方顯示的路徑為根目錄結構

---

## 階段 1：設定（共享基礎建設）

**目的**: 專案初始化和基本結構

- [X] T001 根據實作計畫建立專案結構（建立根目錄的 data/ 和 assets/images/ 資料夾）
- [X] T002 建立基本 HTML 檔案 index.html（包含基本結構：head、body、輸入表單區塊）
- [X] T003 [P] 建立基本 CSS 檔案 styles.css（定義 CSS 變數、基本版面配置）
- [X] T004 [P] 建立主應用程式檔案 app.js（定義模組結構和全域變數）

---

## 階段 2：基礎設施（阻塞前置條件）

**目的**: 所有使用者故事必須完成的核心基礎建設

**⚠️ 關鍵**: 在此階段完成前，任何使用者故事工作都無法開始

- [X] T005 建立信用卡資料檔案 data/credit-cards.json（包含至少 3 張測試信用卡資料）
- [X] T006 [P] 建立平台解析規則檔案 data/platform-rules.json（定義蝦皮、momo、PChome 的選擇器）
- [X] T007 [P] 建立聯盟連結模板檔案 data/affiliate-links.json（定義各平台的聯盟連結格式）
- [X] T008 [P] 在 app.js 實作 ConfigLoader.loadCreditCards() 模組（載入信用卡資料）
- [X] T009 [P] 在 app.js 實作 ConfigLoader.loadPlatformRules() 模組（載入平台規則）
- [X] T010 [P] 在 app.js 實作 ConfigLoader.loadAffiliateTemplates() 模組（載入聯盟模板）
- [X] T011 在 app.js 實作 StorageManager.saveRecentSearch() 模組（儲存查詢記錄到 LocalStorage）
- [X] T012 [P] 在 app.js 實作 StorageManager.getRecentSearches() 模組（讀取查詢記錄）

**檢查點**: 基礎建設就緒 - 使用者故事實作現在可以並行開始

---

## 階段 3：使用者故事 1 - 比價與推薦最佳購買平台 (優先級: P1) 🎯 MVP

**目標**: 使用者貼上商品網址，系統顯示多平台價格比較，標示最便宜選項

**獨立測試**: 使用者貼上主流電商連結，系統顯示至少 3 個平台的價格比較結果並標示最便宜選項

### 實作使用者故事 1

- [X] T013 [P] [US1] 在 app.js 實作 ProductParser.parseProductUrl() 模組（解析商品網址，提取平台和商品資訊）
- [X] T014 [P] [US1] 在 app.js 實作 PriceFetcher.fetchSinglePlatform() 內部函數（使用 CORS proxy 爬取單一平台價格）
- [X] T015 [US1] 在 app.js 實作 PriceFetcher.fetchPricesFromAllPlatforms() 模組（並行爬取多個平台，依賴 T014）
- [X] T016 [US1] 在 app.js 實作聯盟連結生成邏輯（根據 affiliate-links.json 模板生成追蹤連結）
- [X] T017 [US1] 在 app.js 實作 UIRenderer.renderPriceComparison() 模組（渲染價格比較清單，標示最便宜選項）
- [X] T018 [US1] 在 index.html 新增商品網址輸入表單（包含輸入框和「開始比價」按鈕）
- [X] T019 [US1] 在 index.html 新增價格比較結果區塊（用於顯示各平台價格）
- [X] T020 [US1] 在 styles.css 新增價格比較清單樣式（包含最便宜標記、平台卡片樣式）
- [X] T021 [US1] 在 app.js 實作主流程：連結表單提交事件到完整比價流程（整合 ProductParser → PriceFetcher → UIRenderer）
- [X] T022 [US1] 在 app.js 新增錯誤處理邏輯（處理無效網址、不支援平台、爬取失敗等情況）

**檢查點**: 此時，使用者故事 1 應該完全可用且可獨立測試

---

## 階段 4：使用者故事 2 - 信用卡優惠推薦 (優先級: P2)

**目標**: 使用者選擇購買平台後，系統推薦最優惠的信用卡並顯示可省金額

**獨立測試**: 使用者選擇平台後，系統顯示至少 3 張信用卡的優惠比較，包含回饋金額和辦卡連結

### 實作使用者故事 2

- [X] T023 [P] [US2] 在 app.js 實作 CreditCardMatcher.calculateBenefit() 內部函數（計算單張信用卡的實際優惠金額）
- [X] T024 [US2] 在 app.js 實作 CreditCardMatcher.findBestCards() 模組（找出適用平台的最優惠信用卡，依賴 T023）
- [X] T025 [US2] 在 app.js 實作 UIRenderer.renderCreditCardRecommendations() 模組（渲染信用卡推薦清單）
- [X] T026 [US2] 在 index.html 新增信用卡推薦區塊（用於顯示信用卡優惠清單）
- [X] T027 [US2] 在 styles.css 新增信用卡推薦樣式（卡片佈局、優惠標籤、辦卡按鈕）
- [X] T028 [US2] 在 app.js 整合信用卡推薦流程到主流程（在價格比較完成後自動顯示信用卡推薦）

**檢查點**: 此時，使用者故事 1 和 2 應該都能獨立運作

---

## 階段 5：使用者故事 3 - 綜合最划算方案顯示 (優先級: P3)

**目標**: 系統自動計算所有「平台 + 信用卡」組合，顯示最終實付價格最低的方案

**獨立測試**: 使用者查看結果時，頁面頂部顯示「最佳組合」區塊，包含最優方案的完整資訊

### 實作使用者故事 3

- [ ] T029 [US3] 在 app.js 實作 DealCalculator.calculateBestDeal() 模組（計算所有平台與信用卡組合，找出最佳方案）
- [ ] T030 [US3] 在 app.js 實作 UIRenderer.renderBestDeal() 模組（渲染最佳方案區塊到頁面頂部）
- [ ] T031 [US3] 在 index.html 新增最佳方案區塊（醒目的頂部區塊，顯示最優組合）
- [ ] T032 [US3] 在 styles.css 新增最佳方案樣式（醒目配色、大字體、突出顯示）
- [ ] T033 [US3] 在 app.js 整合最佳方案計算到主流程（在信用卡推薦完成後計算並顯示最佳方案）

**檢查點**: 所有使用者故事現在應該都能獨立運作

---

## 階段 6：潤色與跨切面關注點

**目的**: 影響多個使用者故事的改進

- [ ] T034 [P] 在 styles.css 新增響應式設計支援（手機版適配）
- [ ] T035 [P] 在 index.html 和 styles.css 新增載入動畫（爬取資料時的載入指示器）
- [ ] T036 在 app.js 新增 CORS proxy 自動切換邏輯（當一個 proxy 失敗時自動切換到備用）
- [ ] T037 [P] 建立 README.md 檔案（包含專案說明、使用方式、開發指南）
- [ ] T038 在 index.html 最佳化 SEO meta 標籤（title、description、keywords）
- [ ] T039 在 app.js 新增效能最佳化（價格爬取逾時控制、並行請求限制）
- [ ] T040 執行 quickstart.md 中的手動測試驗證（測試所有使用者故事的驗收場景）

---

## 依賴關係與執行順序

### 階段依賴

- **設定（階段 1）**: 無依賴 - 可立即開始
- **基礎設施（階段 2）**: 依賴設定完成 - **阻塞所有使用者故事**
- **使用者故事（階段 3+）**: 全部依賴基礎設施階段完成
  - 使用者故事可並行進行（如果有多位開發者）
  - 或依優先級順序進行（P1 → P2 → P3）
- **潤色（最終階段）**: 依賴所有想要的使用者故事完成

### 使用者故事依賴

- **使用者故事 1 (P1)**: 可在基礎設施（階段 2）後開始 - 不依賴其他故事
- **使用者故事 2 (P2)**: 可在基礎設施（階段 2）後開始 - 可能整合 US1 但應可獨立測試
- **使用者故事 3 (P3)**: 可在基礎設施（階段 2）後開始 - 可能整合 US1/US2 但應可獨立測試

### 每個使用者故事內部

- 模組實作在 UI 實作之前
- 內部函數在使用它們的函數之前
- 核心實作在整合之前
- 故事完成後再移到下一個優先級

### 並行機會

- 所有標記 [P] 的設定任務可並行執行
- 所有標記 [P] 的基礎設施任務可並行執行（在階段 2 內）
- 基礎設施階段完成後，所有使用者故事可並行開始（如果團隊容量允許）
- 使用者故事內標記 [P] 的任務可並行執行
- 不同使用者故事可由不同團隊成員並行開發

---

## 並行範例：使用者故事 1

```bash
# 一起啟動使用者故事 1 的所有並行任務：
Task: "在 app.js 實作 ProductParser.parseProductUrl() 模組"
Task: "在 app.js 實作 PriceFetcher.fetchSinglePlatform() 內部函數"
```

---

## 實作策略

### MVP 優先（僅使用者故事 1）

1. 完成階段 1：設定
2. 完成階段 2：基礎設施（關鍵 - 阻塞所有故事）
3. 完成階段 3：使用者故事 1
4. **停止並驗證**: 獨立測試使用者故事 1
5. 如果就緒就部署/展示

### 漸進式交付

1. 完成設定 + 基礎設施 → 基礎就緒
2. 新增使用者故事 1 → 獨立測試 → 部署/展示（MVP！）
3. 新增使用者故事 2 → 獨立測試 → 部署/展示
4. 新增使用者故事 3 → 獨立測試 → 部署/展示
5. 每個故事都增加價值而不破壞先前的故事

### 並行團隊策略

多位開發者的情況：

1. 團隊一起完成設定 + 基礎設施
2. 基礎設施完成後：
   - 開發者 A：使用者故事 1
   - 開發者 B：使用者故事 2
   - 開發者 C：使用者故事 3
3. 故事獨立完成並整合

---

## 備註

- [P] 任務 = 不同檔案，無依賴
- [Story] 標籤將任務對應到特定使用者故事以便追蹤
- 每個使用者故事應該可獨立完成和測試
- 在實作前確認檔案路徑正確
- 每個任務或邏輯群組後提交
- 在任何檢查點停下來獨立驗證故事
- 避免：模糊任務、相同檔案衝突、破壞獨立性的跨故事依賴
